# Enterprise AI Context VSCode Extension - Cursor Rules

## Project Context
VSCode extension bridging business requirements and code implementation through MCP architecture. TypeScript with CommonJS modules, ES2020 target, strict compilation.

## Architecture Rules

### Layer Separation (STRICT)
```
providers/ ↔ services/ ↔ server/ ↔ mock/
```
- **NO** VS Code API outside `extension.ts`, `providers/`, `ui/`
- **NO** server imports in providers
- Use dependency injection pattern

### File Structure
```
aidm-vscode-extension/
├── 📦 Package & Configuration
│   ├── package.json                    # Extension metadata, dependencies, scripts
│   ├── package-lock.json              # Locked dependency versions
│   ├── tsconfig.json                  # TypeScript compilation settings
│   ├── webpack.config.js              # Webpack bundling configuration
│   ├── jest.config.js                 # Jest testing configuration
│   └── .cursorrules                   # Cursor AI coding rules
│
├── 🚀 Source Code (src/)
│   ├── extension.ts                   # Main entry point (596 lines)
│   │
│   ├── 🏗️ Architecture Layers
│   │   ├── server/                    # MCP Server Components (Pure Business Logic)
│   │   │   ├── SimpleMCPServer.ts    # HTTP JSON-RPC server (1,568 lines)
│   │   │   ├── ProcessManager.ts     # Server lifecycle management
│   │   │   ├── ContextManager.ts     # Business context retrieval
│   │   │   ├── MockCache.ts          # Fast response caching
│   │   │   └── index.ts              # Server exports
│   │   │
│   │   ├── providers/                 # VS Code Language Features
│   │   │   ├── hoverProvider.ts      # Business context hover (864 lines)
│   │   │   └── index.ts              # Provider exports
│   │   │
│   │   ├── services/                  # Core Business Services (Stateless)
│   │   │   ├── TasksDataService.ts   # Task data management
│   │   │   ├── MarkdownTaskParser.ts # Markdown task parsing
│   │   │   ├── TaskStatusManager.ts  # Task lifecycle management
│   │   │   ├── CacheManager.ts       # Response caching with TTL
│   │   │   └── index.ts              # Service exports
│   │   │
│   │   ├── ui/                       # VS Code UI Components
│   │   │   ├── statusBar.ts          # Connection status display
│   │   │   ├── demoPanel.ts          # Interactive demo panel
│   │   │   ├── configurationPanel.ts # Configuration interface
│   │   │   └── index.ts              # UI exports
│   │   │
│   │   ├── client/                   # MCP Client Components
│   │   │   ├── mcpClient.ts          # Standard MCP client
│   │   │   ├── hybridMCPClient.ts    # Hybrid local/remote client
│   │   │   └── index.ts              # Client exports
│   │   │
│   │   ├── utils/                     # Pure Utility Functions (No Side Effects)
│   │   │   ├── ErrorHandler.ts       # Centralized error handling
│   │   │   ├── DegradedModeManager.ts # Graceful degradation
│   │   │   ├── logger.ts             # Structured logging
│   │   │   ├── portFinder.ts         # Smart port selection
│   │   │   ├── auditTrail.ts         # User action tracking
│   │   │   ├── configLoader.ts       # Configuration loading
│   │   │   └── degradedMode.ts       # Degraded mode utilities
│   │   │
│   │   ├── types/                     # Shared TypeScript Definitions
│   │   │   ├── business.ts           # Business domain types
│   │   │   ├── extension.ts          # VS Code specific types
│   │   │   ├── jsonrpc.ts            # MCP/JSON-RPC protocol types
│   │   │   ├── tasks.ts              # Task management types
│   │   │   └── index.ts              # Central barrel exports
│   │   │
│   │   ├── mock/                      # Development & Demo Data
│   │   │   ├── MockDataProvider.ts   # Enterprise data generation (647 lines)
│   │   │   ├── sampleData.ts         # Pre-built enterprise datasets
│   │   │   └── index.ts              # Mock data exports
│   │   │
│   │   ├── demo/                      # Demo & Integration Components
│   │   │   ├── demoScenarios.ts      # Enterprise demo scenarios (482 lines)
│   │   │   ├── rooCodeIntegration.ts # RooCode AI integration
│   │   │   ├── runDemo.ts            # Demo orchestration
│   │   │   ├── demoConfiguration.ts  # Demo configuration
│   │   │   ├── rooCodeIntegrationDemo.ts # RooCode demo
│   │   │   └── sampleFiles/          # Realistic enterprise code samples
│   │   │       ├── DashboardAnalytics.ts  # Analytics scenarios (479 lines)
│   │   │       ├── UserService.ts          # User management (262 lines)
│   │   │       ├── PaymentProcessor.ts     # Payment processing (459 lines)
│   │   │       └── FraudDetection.ts       # ML inference (51 lines)
│   │   │
│   │   ├── security/                  # Security & Compliance
│   │   │   ├── AuditLogger.ts        # Comprehensive audit logging
│   │   │   └── EncryptionUtil.ts     # Data encryption utilities
│   │   │
│   │   ├── ml/                        # Machine Learning Integration
│   │   │   └── InferenceService.ts   # ML inference service
│   │   │
│   │   ├── config/                    # Configuration Management
│   │   │   └── extensionConfig.ts    # Extension configuration schema
│   │   │
│   │   ├── models/                    # Data Models
│   │   │   ├── Analytics.ts          # Analytics tracking model
│   │   │   ├── Payment.ts            # Payment processing model
│   │   │   └── User.ts               # User management model
│   │   │
│   │   ├── tasks/                     # Task Management System
│   │   │   ├── providers/             # Task UI Components
│   │   │   │   ├── TaskTreeItem.ts   # Task tree view items
│   │   │   │   ├── TaskTreeViewProvider.ts # Task tree provider
│   │   │   │   └── index.ts          # Task provider exports
│   │   │   ├── services/              # Task Business Services
│   │   │   │   └── index.ts          # Task service exports
│   │   │   ├── types/                 # Task Type Definitions
│   │   │   │   ├── taskEnums.ts      # Task enumeration types
│   │   │   │   ├── taskInterfaces.ts # Task interface definitions
│   │   │   │   ├── taskJsonRpc.ts    # Task JSON-RPC types
│   │   │   │   ├── taskTypes.ts      # Core task types
│   │   │   │   └── index.ts          # Task type exports
│   │   │   └── index.ts              # Task system exports
│   │   │
│   │   └── __tests__/                 # Comprehensive Test Suites.
│   │       ├── jest.setup.ts          # Jest global configuration
│   │       ├── __mocks__/             # Jest mock implementations
│   │       │   └── vscode.ts         # VS Code API mocks
│   │       ├── unit/                  # Single component tests
│   │       ├── integration/           # Component interaction tests
│   │       ├── e2e/                   # Full workflow tests
│   │       ├── server/                # MCP server specific tests
│   │       ├── mock/                  # Mock data tests
│   │       ├── services/              # Service layer tests
│   │       ├── tasks/                 # Task system tests
│   │       ├── utils/                 # Utility function tests
│   │       └── ...                    # Other test files
│   │
│   └── index.ts                       # Main source exports
│
├── 📚 Documentation
├── 🛠️ Build & Development Scripts
├── 🎨 Resources
├── 📊 Coverage & Build Artifacts
└── 🔧 Development Tools
```

## TypeScript Standards

### Compilation
- Target: ES2020, CommonJS modules
- Strict mode: ALWAYS enabled
- Import from barrel exports (`index.ts`), not individual files
- All dates as ISO 8601 strings in API responses

### Type Organization
```typescript
// Single source of truth for task types
import { Task, TaskExecutionContext } from './tasks/types';

// Import from barrels
import { BusinessContext, Requirement } from './types';
import { TasksDataService } from './services';
import { TaskTreeViewProvider } from './tasks/providers';
```

## Development Patterns

### Error Handling
```typescript
import { ErrorHandler } from './utils/ErrorHandler';
import { DegradedModeManager } from './utils/DegradedModeManager';

try {
  const context = await this.contextManager.retrieve(location);
  return context;
} catch (error) {
  ErrorHandler.handle(error, { context: 'component-name', location });
  return DegradedModeManager.getFallbackContext(location);
}
```

### Enhanced Error Recovery Patterns
```typescript
// Comprehensive error handling with specific recovery strategies
try {
  const result = await service.operation();
  return result;
} catch (error) {
  if (error.code === 'NETWORK_TIMEOUT') {
    return DegradedModeManager.getOfflineFallback();
  }
  if (error.code === 'PERMISSION_DENIED') {
    return DegradedModeManager.getReadOnlyFallback();
  }
  if (error.code === 'FILE_NOT_FOUND') {
    return DegradedModeManager.getMockFallback();
  }
  ErrorHandler.handle(error, { context: 'operation-name' });
  throw error;
}
```

### Testing (TDD Required)
```typescript
// Test structure: *.test.ts files in __tests__/ matching src/ structure
describe('ComponentName', () => {
  // Arrange, Act, Assert pattern
  it('should handle specific behavior', async () => {
    // Arrange: setup test data
    const mockData = { id: '1', status: 'not_started' };
    
    // Act: execute function
    const result = await service.process(mockData);
    
    // Assert: verify outcome
    expect(result).toBeDefined();
  });
});

// Test file organization mirrors src/ structure exactly:
// - Unit tests: src/__tests__/unit/ → src/unit/ components
// - Integration tests: src/__tests__/integration/ → src/integration/ components
// - E2E tests: src/__tests__/e2e/ → full workflow testing
// - Server tests: src/__tests__/server/ → src/server/ components
// - Service tests: src/__tests__/services/ → src/services/ components
// - Task tests: src/__tests__/tasks/ → src/tasks/ components
```

### Mock Data Patterns
```typescript
// API responses must match exact format
const mockResponse = {
  jsonrpc: "2.0",
  result: {
    content: [{
      text: JSON.stringify({
        id: "task-1",
        createdDate: "2024-01-01T00:00:00.000Z", // String dates only
        lastModified: "2024-01-02T00:00:00.000Z"
      })
    }]
  }
};

// Use MockDataProvider for enterprise scenarios
import { MockDataProvider } from './mock/MockDataProvider';
const mockProvider = new MockDataProvider();
const enterpriseScenario = mockProvider.getEnterpriseScenario("fintech");
```

## Performance Targets
- Hover Provider: <200ms
- MCP Server Tools: <300ms
- Task Tree Display: <300ms
- Context Extraction: <800ms
- Prompt Generation: <500ms

## HTTP Client (Axios)
```typescript
import axios from 'axios';

async function callMCPTool(method: string, params: any): Promise<any> {
  const response = await axios.post('http://localhost:3000/rpc', {
    jsonrpc: "2.0",
    method: "tools/call",
    params: { name: method, arguments: params },
    id: Date.now()
  }, {
    timeout: 5000,
    headers: { 'Content-Type': 'application/json' }
  });
  
  return response.data.result;
}
```

## Build System
```bash
npm run watch      # Development (webpack)
npm run compile    # Production build
npm run test       # Jest tests
npm run lint       # ESLint

# Terminal is already in project directory - NO cd commands needed
# Use relative paths: ./src/file.ts
```

## Cursor Integration Patterns

### Context Extraction for Tasks
```typescript
// Extract focused context for atomic tasks
interface TaskPromptContext {
  task: Task;
  dependencies: string[];        // Just IDs and status
  requirements: string[];         // 1-2 sentences each
  acceptanceCriteria: string[];   // Checklist items
  codeContext: {
    relevantFiles: string[];      // Essential files only
    patterns: string[];           // Key patterns to follow
  };
}

// Use existing services for context extraction
import { TasksDataService } from './services/TasksDataService';
import { MarkdownTaskParser } from './services/MarkdownTaskParser';
```

### Prompt Generation Rules
- Keep prompts atomic and focused
- Include TDD instructions
- Reference specific files, not entire directories
- Limit context to essential information

## Anti-Patterns to Avoid
- ❌ Generic `any` types
- ❌ Console.log in production code
- ❌ Synchronous file operations
- ❌ Direct file system access in providers
- ❌ Date objects in API responses (use strings)
- ❌ Complex nested promises (use async/await)
- ❌ cd commands in terminal (already in workspace)
- ❌ Importing from individual files instead of barrel exports
- ❌ Importing from non-existent paths (e.g., './task-management/types')
- ❌ Using relative paths that dont match actual directory structure

## Spec File References

### When to Check Specs
- **requirements.md**: For acceptance criteria and user stories
- **design.md**: For architectural patterns and interfaces
- **tasks.md**: For implementation steps and dependencies
- **types/index.ts**: For all type definitions

### Implementation Validation
Every feature must:
1. Map to a requirement ID from requirements.md
2. Follow patterns from design.md
3. Use types from types/index.ts
4. Complete acceptance criteria (WHEN/THEN format)

## Task Implementation Template
```typescript
/**
 * Task: [Task ID] - [Task Title]
 * Requirements: [Requirement IDs]
 * Dependencies: [Task IDs]
 * Complexity: [low|medium|high]
 * Time: [15-30 minutes]
 */
class Implementation {
  // 1. Write test first (TDD)
  // 2. Implement minimum to pass
  // 3. Refactor if needed
  // 4. Verify integration
}
```

## Documentation Update Requirements

### Post-Task Documentation Updates (MANDATORY)

**After completing ANY task, developers MUST update relevant documentation:**

#### 1. **tasks.md Updates**
```markdown
# Update tasks.md after task completion
- [x] [Task ID] - [Task Title] ✅ COMPLETED
- [ ] [Next Task ID] - [Next Task Title] (if dependencies are now satisfied)
- Update task status: not_started → in_progress → completed
- Add completion timestamp and any blockers encountered
- Document any deviations from planned approach
```

#### 2. **design.md Updates**
```markdown
# Update design.md if architectural changes were made
- Document new component interfaces or patterns
- Update component diagrams if structure changed
- Add new integration patterns or data flows
- Document performance improvements or optimizations
- Update error handling strategies if enhanced
```

#### 3. **requirements.md Updates**
```markdown
# Update requirements.md if acceptance criteria were modified
- Verify all acceptance criteria are met
- Document any new requirements discovered during implementation
- Update user story details if implementation revealed gaps
- Add new edge cases or scenarios identified
- Document performance metrics achieved
```

#### 4. **Implementation Notes**
```typescript
/**
 * Task: [Task ID] - [Task Title] ✅ COMPLETED
 * Completion Date: [YYYY-MM-DD]
 * Requirements Met: [Requirement IDs]
 * Dependencies Satisfied: [Task IDs]
 * 
 * Documentation Updated:
 * - [x] tasks.md - Task status updated
 * - [x] design.md - [Describe architectural changes]
 * - [x] requirements.md - [Describe requirement updates]
 * - [x] [Other relevant docs]
 * 
 * Implementation Notes:
 * - [Key decisions made]
 * - [Challenges encountered]
 * - [Performance considerations]
 * - [Future enhancement opportunities]
 */
```

### Documentation Update Checklist

**Before marking any task as complete, verify:**

- [ ] **tasks.md**: Task status updated to "completed" with timestamp
- [ ] **design.md**: Any new patterns, interfaces, or diagrams documented
- [ ] **requirements.md**: Acceptance criteria verified and any gaps documented
- [ ] **Code Comments**: JSDoc comments include requirement IDs and design references
- [ ] **Test Coverage**: Tests document the implemented behavior
- [ ] **Integration Points**: Any new integration patterns documented

### Documentation Standards

#### **Update Frequency**
- **Immediate**: Update tasks.md when task status changes
- **Before Commit**: Ensure all relevant docs are updated
- **Before PR**: Verify documentation completeness
- **After Review**: Incorporate feedback into documentation

#### **Update Quality**
- **Accuracy**: Documentation must match actual implementation
- **Completeness**: All changes must be documented
- **Consistency**: Use established documentation patterns
- **Traceability**: Link code changes to requirement IDs

#### **Common Documentation Updates**

**For UI Components:**
```markdown
# design.md updates
- Component interface definitions
- UI/UX patterns and interactions
- Performance targets and measurements
- Error handling and user feedback
- Accessibility considerations
```

**For Business Logic:**
```markdown
# design.md updates
- Service interface definitions
- Data flow diagrams
- Error handling strategies
- Performance optimization patterns
- Integration patterns with external systems
```

**For Testing:**
```markdown
# design.md updates
- Test strategy and coverage requirements
- Mock data patterns and standards
- Performance testing approaches
- Integration testing workflows
- Test data management strategies
```

### Documentation Validation

#### **Self-Validation Checklist**
```typescript
// Before committing, ask yourself:
// 1. Does the code match whats documented in design.md?
// 2. Are all requirements from requirements.md satisfied?
// 3. Is the task properly marked as complete in tasks.md?
// 4. Are there any new patterns that should be documented?
// 5. Have I documented any deviations from the planned approach?
```

#### **Review Validation**
```typescript
// During code review, verify:
// 1. Documentation updates are included in the PR
// 2. All relevant spec files have been updated
// 3. New patterns are properly documented
// 4. Requirements traceability is maintained
// 5. Design consistency is preserved
```

### Anti-Patterns for Documentation

- ❌ **Completing tasks without updating documentation**
- ❌ **Documenting changes in code comments only**
- ❌ **Updating one spec file but not others**
- ❌ **Forgetting to update task status in tasks.md**
- ❌ **Documenting assumptions instead of actual implementation**
- ❌ **Missing requirement IDs in code comments**
- ❌ **Inconsistent documentation patterns across components**

## Component Import Patterns

### Correct Import Paths
```typescript
// ✅ Correct: Import from barrel exports
import { TasksDataService } from './services';
import { TaskTreeViewProvider } from './tasks/providers';
import { Task, TaskStatus } from './tasks/types';
import { BusinessContext } from './types';

// ❌ Incorrect: Import from individual files
import { TasksDataService } from './services/TasksDataService';
import { Task } from './tasks/types/taskTypes';
```

### Real Project Component Examples
```typescript
// Real project import examples:
import { SimpleMCPServer } from './server';
import { MockDataProvider } from './mock';
import { demoScenarios } from './demo';
import { AuditLogger } from './security';
import { InferenceService } from './ml/InferenceService';
import { Analytics } from './models/Analytics';
```

### Service Layer Integration
```typescript
// Use established service patterns
import { TasksDataService } from './services';
import { MarkdownTaskParser } from './services';
import { TaskStatusManager } from './services';

// Connect to MCP server via TasksDataService
const tasksService = new TasksDataService();
const tasks = await tasksService.getTasks();
```

### UI Component Integration
```typescript
// Use established UI patterns
import { TaskTreeViewProvider } from './tasks/providers';
import { TaskDetailCardProvider } from './tasks/providers';

// Register with VSCode extension
context.subscriptions.push(
  vscode.window.registerTreeDataProvider('tasks-tree', taskTreeProvider)
);
```

## Integration Patterns

### Demo System Integration
```typescript
// Demo integration patterns:
import { demoScenarios } from './demo';
import { runDemo } from './demo';
import { sampleFiles } from './demo/sampleFiles';

// Use realistic enterprise scenarios for testing
const fintechDemo = demoScenarios.getScenario("fintech-payment-processing");
await runDemo.execute(fintechDemo);
```

### Security Component Integration
```typescript
// Security integration patterns:
import { AuditLogger } from './security/AuditLogger';
import { EncryptionUtil } from './security/EncryptionUtil';

// Always audit sensitive operations
auditLogger.logAccess("task-update", { taskId, userId, timestamp });

// Encrypt sensitive data when needed
const encryptedData = EncryptionUtil.encrypt(sensitiveBusinessData);
```

### ML Integration Patterns
```typescript
// ML integration patterns:
import { InferenceService } from './ml/InferenceService';

// Use for fraud detection in PaymentProcessor.ts sample
const fraudScore = await inferenceService.detectFraud(paymentData);
```

### Configuration Management
```typescript
// Configuration patterns:
import { loadConfig } from './utils/configLoader';
import { ExtensionConfig } from './config/extensionConfig';

// Load and validate configuration on startup
const config = await loadConfig();
```

### Performance Monitoring Integration
```typescript
// Performance monitoring patterns:
import { Analytics } from './models/Analytics';

// Track performance metrics
analytics.trackHoverEvent(filePath, position);
analytics.trackContextRetrieval(businessContext);
```

## File Size Guidelines

### File Size Awareness
```typescript
// File size guidelines (based on actual project):
// Large files (>500 lines): SimpleMCPServer.ts (1,568 lines)
// Medium files (200-500 lines): hoverProvider.ts (864 lines), MockDataProvider.ts (647 lines)
// Small files (<200 lines): Most utility and type files

// Guidelines:
// - Break down files >500 lines into smaller, focused modules
// - Keep utility files <100 lines for maintainability
// - Large files should be architectural components with clear responsibilities
// - Consider refactoring when files exceed 800 lines
```

## VSCode Extension Patterns

### Extension Lifecycle
```typescript
// Follow your extension.ts pattern - keep lightweight
export async function activate(
  context: vscode.ExtensionContext
): Promise<void> {
  // Initialize core managers first
  const processManager = new ProcessManager();
  const statusBarManager = new StatusBarManager();

  // Register providers
  const hoverProvider = new BusinessContextHoverProvider(contextManager);
  context.subscriptions.push(
    vscode.languages.registerHoverProvider("typescript", hoverProvider)
  );

  // Initialize UI components
  const demoPanel = new DemoPanel(context);
  const configPanel = new ConfigurationPanel(context);
}

export function deactivate(): Thenable<void> | undefined {
  // Use your ProcessManager for cleanup
  return ProcessManager.getInstance().cleanup();
}
```

### Status Bar Integration
```typescript
// Follow your established StatusBarManager pattern
import { StatusBarManager } from "./ui/statusBar";

const statusBar = new StatusBarManager();
statusBar.updateConnectionStatus("connected");
statusBar.showHealthMetrics();
```

## MCP Server Architecture

### Server Management
```typescript
// Follow your SimpleMCPServer architecture
import { SimpleMCPServer } from "./server/SimpleMCPServer";
import { ProcessManager } from "./server/ProcessManager";

class MCPServerManager {
  private server: SimpleMCPServer;
  private processManager: ProcessManager;

  async start(): Promise<void> {
    // Use your ProcessManager for lifecycle
    this.processManager = new ProcessManager();
    await this.processManager.startServer();

    // Initialize your SimpleMCPServer
    this.server = new SimpleMCPServer();
    await this.server.start();
  }
}
```

### Context Management
```typescript
// Follow your ContextManager.ts established patterns
import { ContextManager } from "./server/ContextManager";
import { MockCache } from "./server/MockCache";

const contextManager = new ContextManager();
const mockCache = new MockCache();

// Use your established context retrieval patterns
const businessContext = await contextManager.getBusinessContext(codeLocation);
```

## Testing & Mock Data Standards

### HTTP Client Mocking Rules
- **Response Format**: Mock HTTP responses must match the exact format returned by real APIs
- **Date Handling**: Use string dates in mock responses, not Date objects
- **Type Consistency**: Mock data types must match production API response types

### Test Data Creation Guidelines
- **API-First Approach**: Create mock data that matches the actual API response structure
- **Date Fields**: Always use ISO 8601 strings for date fields in mock responses
- **Validation**: Verify mock data structure matches the real API before writing tests

### Example Implementation Pattern
```typescript
// ✅ CORRECT PATTERN
describe("API Response Testing", () => {
  it("should handle MCP server response format", async () => {
    // 1. Create mock data with correct types (string dates)
    const mockTask = {
      id: "test-123",
      createdDate: "2024-01-01T00:00:00.000Z", // String date
      lastModified: "2024-01-02T00:00:00.000Z", // String date
    };

    // 2. Mock HTTP response with correct format
    mockHttpClient.post.mockResolvedValue({
      data: { jsonrpc: "2.0", result: { task: mockTask } },
    });

    // 3. Test the actual behavior
    const result = await service.getTaskById("test-123");
    expect(result.createdDate).toBe("2024-01-01T00:00:00.000Z");
  });
});
```

## Terminal & Command Execution

### Terminal Context Awareness
```bash
# The terminal is ALREADY in the project workspace
# Current working directory: ~/[logs]/[workspace]/[repos]/[manual shelf]/aidm-vscode-extension
# DO NOT add unnecessary `cd` commands before npm scripts

# ✅ Correct: Direct command execution
npm test -- --testPathPattern="MarkdownTaskParser" --verbose
npm run lint
npm run compile

# ❌ Incorrect: Unnecessary cd with unquoted paths (causes "too many arguments" error)
cd /c/Users/yi.a.cheong/[logs]/[workspace]/[repos]/[manual shelf]/aidm-vscode-extension && npm test
```

### Test Command Patterns
```bash
# Running specific tests (correct format)
npm test -- --testPathPattern="ComponentName" --verbose
npm test -- --testNamePattern="should handle hover requests"
npm test -- src/__tests__/unit/hoverProvider.test.ts

# Running test suites by directory
npm test -- src/__tests__/unit/
npm test -- src/__tests__/integration/
npm test -- src/__tests__/server/

# Full test suite
npm test
npm run test
```

## Performance Optimization

### Extension Bundle Optimization
```typescript
// Your webpack config bundles everything into dist/extension.js
// Optimization rules:
// - Minimize dependencies in production bundle
// - Use axios efficiently (its your only runtime dependency)
// - Lazy load demo components (src/demo/) only when needed
// - Cache MockDataProvider responses to reduce bundle parsing time

// Example lazy loading for demo features:
async function loadDemoComponents() {
  const { DemoScenarios } = await import("../demo/demoScenarios");
  const { runDemo } = await import("../demo/runDemo");
  return { DemoScenarios, runDemo };
}
```

## Spec File Integration

### When to Reference Spec Files
**ALWAYS reference specs for:**
- New feature development
- Major architectural changes
- Component interface modifications
- Business logic implementation
- Integration between major components (providers ↔ server ↔ mock)

**Optional for:**
- Bug fixes in existing functionality
- Performance optimizations
- Refactoring without behavior changes
- Pure utility functions
- Test improvements

### Spec-Driven Development Rules
- **Requirements Traceability**: Every major function should map to a requirement ID
- **Design Compliance**: Follow established patterns in design.md (dont invent new ones)
- **Task Alignment**: Check tasks.md to see if implementation matches planned approach
- **Acceptance Criteria**: Validate code meets the specific WHEN/THEN criteria from requirements.md

### Documentation Comments (Reference Specs)
```typescript
/**
 * Provides business context hover information for TypeScript files
 *
 * Requirements: 1.1, 1.2, 1.4 (hover display within 200ms)
 * Design: BusinessContextHoverProvider pattern from design.md
 * Implementation: Task 6 - VSCode extension with hover provider
 */
class BusinessContextHoverProvider {
  /**
   * Requirements 1.1: Display relevant business context within 200ms
   * Requirements 1.5: Handle errors gracefully without breaking hover
   */
  async provideHover(
    document: TextDocument,
    position: Position
  ): Promise<Hover | null> {
    // Implementation here...
  }
}
```

## Taskmaster Dashboard Implementation Rules (NEW FEATURE)

### Visual Design Compliance (MANDATORY)
- **Mockup Reference**: taskmaster_mockup.html is the single source of truth for UI design
- **Exact Visual Match**: All UI components must match the mockup pixel-perfect
- **CSS Classes**: Use the exact CSS class names and structure from the mockup
- **Accordion Behavior**: Only one task expanded at a time (lines 350-410 in mockup)
- **Executable Tasks**: Blue left border + 🤖 icon when `isExecutable: true && status: "not_started"`

### Enhanced Data Structures (REQUIRED)
```typescript
// All task implementations must use these enhanced fields
interface Task {
  // Core existing fields from your project
  id: string;
  title: string;
  description: string;
  status: TaskStatus;
  complexity: TaskComplexity;
  dependencies: string[];
  requirements: string[];
  
  // MANDATORY enhanced fields
  estimatedDuration?: string; // "15-30 min" format
  isExecutable?: boolean; // For Cursor integration
  createdDate: string; // ISO string only (follow your date rules)
  lastModified: string; // ISO string only
  
  // Enhanced test results
  testStatus?: {
    lastRunDate?: string; // ISO format only
    totalTests: number;
    passedTests: number;
    failedTests: number;
    failingTestsList?: FailingTest[];
    coverage?: number;
  }
}

interface FailingTest {
  name: string;
  message: string;
  category: 'assertion' | 'type' | 'filesystem' | 'timeout' | 'network';
  stackTrace?: string;
}
```

### Time Formatting (MANDATORY)
- Use TimeFormattingUtility for ALL timestamps (follow your service patterns)
- Display relative time ("2 hours ago") not absolute dates
- Fallback to absolute time on formatting errors
- Cache relative times with 1-minute TTL (follow your performance targets)

### Status Action Mapping (EXACT IMPLEMENTATION)
```typescript
const STATUS_ACTIONS = {
  not_started: ["🤖 Execute with Cursor", "Generate Prompt", "View Requirements"],
  in_progress: ["Continue Work", "Mark Complete", "View Dependencies"],
  review: ["Approve & Complete", "Request Changes", "View Implementation"],
  completed: ["View Code", "View Tests", "History"],
  blocked: ["View Blockers", "Update Dependencies", "Report Issue"],
  deprecated: ["Archive", "View History"]
};

const STATUS_DISPLAY_NAMES = {
  not_started: "not started",
  in_progress: "in progress",
  review: "review",
  completed: "completed",
  blocked: "blocked",
  deprecated: "deprecated"
};
```

### Test Results Display Rules
- Reference mockup lines 280-340 for exact HTML structure
- Implement collapsible failures section with expand/collapse icons
- Categorize errors: assertion, type, filesystem, timeout, network
- Show individual FailingTest items with proper error styling
- Use your established error handling patterns from ErrorHandler.ts

### File Path Corrections for Taskmaster Tasks
```typescript
// ✅ CORRECT: Use your actual project structure
import { TaskTreeViewProvider } from './tasks/providers';
import { Task, TaskStatus } from './tasks/types';
import { TasksDataService } from './services';
import { TimeFormattingUtility } from './utils'; // If created
import { ErrorHandler } from './utils/ErrorHandler';
import { DegradedModeManager } from './utils/DegradedModeManager';

// ❌ INCORRECT: These paths dont exist in your project
import { TaskTreeViewProvider } from './task-management/ui/TaskTreeViewProvider';
import { Task } from './task-management/types';
```

### Taskmaster Performance Targets (Add to your existing targets)
- Task Tree Display: <300ms (your existing target)
- Task Detail Expansion: <200ms (new)
- Time Formatting: <50ms (new)
- Accordion Animation: <150ms (new)
- Test Results Rendering: <100ms (new)

### Taskmaster Testing Patterns (Follow your TDD rules)
```typescript
// Test structure: Follow your __tests__/ pattern
describe('TaskTreeViewProvider', () => {
  it('should display executable tasks with blue border and robot icon', async () => {
    // Arrange: Use your MockDataProvider patterns
    const mockTask = {
      id: "test-1",
      status: "not_started",
      isExecutable: true,
      estimatedDuration: "15-20 min"
    };
    
    // Act: Follow your async/await patterns
    const treeItem = await provider.getTreeItem(mockTask);
    
    // Assert: Verify mockup compliance
    expect(treeItem.contextValue).toBe("executable-task");
    expect(treeItem.description).toContain("🤖");
  });
});
```

### Mockup Integration Requirements
```typescript
// Every UI task must reference specific mockup sections
/**
 * Task: Implement collapsible test failures section
 * Mockup Reference: lines 350-410 in taskmaster_mockup.html
 * CSS Classes: .failures-section, .failures-header, .failures-list
 * Behavior: Click to expand/collapse with icon rotation
 */
```

### Taskmaster Error Handling (Use your established patterns)
```typescript
// Follow your ErrorHandler and DegradedModeManager patterns
try {
  const tasks = await this.tasksDataService.getTasks();
  return this.renderTaskList(tasks);
} catch (error) {
  ErrorHandler.handle(error, { context: 'taskmaster-component' });
  return DegradedModeManager.getTaskFallback();
}
```

### Taskmaster Mock Data (Follow your MockDataProvider patterns)
```typescript
// Use your established MockDataProvider approach
import { MockDataProvider } from './mock/MockDataProvider';

const mockProvider = new MockDataProvider();
const taskScenario = mockProvider.getTaskScenario("development-workflow");

// Must include enhanced fields in mock data
const mockTaskWithEnhancements = {
  ...baseTask,
  estimatedDuration: "15-30 min",
  isExecutable: true,
  testStatus: {
    lastRunDate: "2024-08-22T14:30:00Z",
    totalTests: 18,
    passedTests: 15,
    failedTests: 3,
    failingTestsList: [
      {
        name: "should validate task status transitions",
        message: "AssertionError: Expected 400 but got 200",
        category: "assertion"
      }
    ]
  }
};
```

### Taskmaster Documentation Updates (Follow your mandatory patterns)
```typescript
/**
 * Task: [Task ID] - [Task Title] 
 * Requirements: [Requirement IDs from requirements.md]
 * Dependencies: [Task IDs from tasks.md]
 * Mockup Reference: [Specific lines in taskmaster_mockup.html]
 * 
 * Documentation Updated:
 * - [x] tasks.md - Task status updated
 * - [x] design.md - UI patterns documented
 * - [x] requirements.md - Acceptance criteria verified
 */
```

### Taskmaster Forbidden Patterns (Add to your existing anti-patterns)
- ❌ UI components that dont match the mockup exactly
- ❌ Using Date objects instead of ISO strings (follow your existing rule)
- ❌ Hardcoded status names instead of STATUS_DISPLAY_NAMES mapping
- ❌ Missing executable task visual indicators
- ❌ Multiple expanded tasks (violates accordion behavior)
- ❌ Absolute timestamps instead of relative formatting
- ❌ Generic error handling without FailingTest categorization
- ❌ Importing from non-existent task-management paths

### Taskmaster VSCode Integration (Follow your extension.ts patterns)
```typescript
// Register taskmaster components in your activate function
export async function activate(context: vscode.ExtensionContext): Promise<void> {
  // Follow your existing ProcessManager and StatusBarManager patterns
  const processManager = new ProcessManager();
  const statusBarManager = new StatusBarManager();
  
  // Add taskmaster providers
  const taskTreeProvider = new TaskTreeViewProvider(tasksDataService);
  context.subscriptions.push(
    vscode.window.registerTreeDataProvider('tasks-list', taskTreeProvider)
  );
  
  // Follow your command registration patterns
  context.subscriptions.push(
    vscode.commands.registerCommand('aidm-vscode-extension.executeTaskWithCursor', 
      async (taskId: string) => {
        // Implementation with your error handling patterns
      }
    )
  );
}
```
