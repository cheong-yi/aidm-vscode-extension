{
  "PERF-001": {
    "taskId": "PERF-001",
    "title": "Remove debug logging from JSON parser production code",
    "promptContent": "# Atomic Task Implementation: PERF-001 - Remove debug logging from JSON parser production code\n\n## Single-Concern Focus\nEliminate excessive console.log statements in JSONTaskParser.validateTasksFile() to resolve the primary performance bottleneck causing 200-500ms delays.\n\n## Sprint Context\n- **Sprint Day**: 1-2 of 2-week sprint\n- **Priority**: P0-Critical Path (blocks user experience)\n- **Dependencies**: None - standalone optimization\n- **Fallback Plan**: Conditional logging based on environment variable\n\n## Context Files (Maximum 2)\n- Target file: src/services/JSONTaskParser.ts (validateTasksFile method, lines 32-80)\n- Reference: Performance analysis identifying 15+ console.log calls per file read\n\n## Task Scope\n- ID: PERF-001\n- Single Responsibility: Remove production debug logging\n- Input: JSONTaskParser.validateTasksFile method\n- Output: Clean validation without console output\n- Duration: 15 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Refactor\n- Cleaning up debug code while preserving functionality\n\n## Prerequisites Verified\n- [x] JSONTaskParser exists and compiles\n- [x] validateTasksFile method contains excessive logging\n- [x] Performance bottleneck confirmed in analysis\n\n## Implementation Specification\n### Exact Method Changes\n```typescript\nprivate async validateTasksFile(\n  fileUri: vscode.Uri\n): Promise<{ isValid: boolean; error?: string }> {\n  try {\n    const stats = await vscode.workspace.fs.stat(fileUri);\n    \n    if (stats.type !== vscode.FileType.File) {\n      return {\n        isValid: false,\n        error: `Path exists but is not a file: ${fileUri.fsPath}`,\n      };\n    }\n    \n    if (stats.size === 0) {\n      return {\n        isValid: false,\n        error: `Tasks file is empty: ${fileUri.fsPath}`,\n      };\n    }\n    \n    return { isValid: true };\n  } catch (error) {\n    return {\n      isValid: false,\n      error: `Cannot access tasks file: ${fileUri.fsPath} - ${error}`,\n    };\n  }\n}\n```\n\n### Single Test Case\n```typescript\nit('should validate file without logging in production', async () => {\n  const consoleSpy = jest.spyOn(console, 'log');\n  await parser.validateTasksFile(validUri);\n  expect(consoleSpy).not.toHaveBeenCalled();\n  consoleSpy.mockRestore();\n});\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] All console.log statements removed from validateTasksFile\n- [x] Method functionality preserved (same return values)\n- [x] Existing tests still pass\n- [x] Performance improvement measurable (200-500ms faster)\n\n## File Changes (Maximum 3 Files)\n### Primary File: src/services/JSONTaskParser.ts\n- Remove: Lines 32-80 console.log statements\n- Preserve: All validation logic and error handling\n- Purpose: Eliminate performance bottleneck\n\n## Validation Commands\n```bash\nnpm test -- --testPathPattern=\"JSONTaskParser\"\nnpm run compile\n# Measure performance before/after with task loading\n```\n\n## Rollback Strategy\n```bash\ngit checkout HEAD -- src/services/JSONTaskParser.ts\n```",
    "contextFiles": ["src/services/JSONTaskParser.ts"],
    "tddPhase": "Refactor",
    "validationSteps": [
      "Remove all console.log statements from validateTasksFile method",
      "Verify method still returns same validation results",
      "Run JSONTaskParser tests to ensure no regression",
      "Measure task loading performance improvement"
    ],
    "rollbackCommand": "git checkout HEAD -- src/services/JSONTaskParser.ts",
    "successSignals": [
      "No console output during task file validation",
      "Task loading time reduced by 200-500ms", 
      "All existing tests pass"
    ]
  },
  "PERF-002": {
    "taskId": "PERF-002", 
    "title": "Configure webpack to bundle CSS at build time",
    "promptContent": "# Atomic Task Implementation: PERF-002 - Configure webpack to bundle CSS at build time\n\n## Single-Concern Focus\nAdd webpack raw-loader configuration to bundle styles.css content at build time, eliminating runtime file system access that causes fallback CSS in packaged extensions.\n\n## Sprint Context\n- **Sprint Day**: 2-3 of 2-week sprint\n- **Priority**: P0-Critical Path (fixes broken styling in packaged extension)\n- **Dependencies**: None - standalone build configuration\n- **Fallback Plan**: Inline CSS directly in TypeScript if webpack config fails\n\n## Context Files (Maximum 2)\n- Target file: webpack.config.js (add raw-loader for CSS)\n- Secondary: src/tasks/providers/TaskHTMLGenerator.ts (update CSS import)\n\n## Task Scope\n- ID: PERF-002\n- Single Responsibility: Bundle CSS at build time via webpack\n- Input: External styles.css file (597 lines)\n- Output: CSS bundled as string in JavaScript bundle\n- Duration: 15 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Green\n- Implementing build-time bundling while preserving functionality\n\n## Prerequisites Verified\n- [x] webpack.config.js exists and is used for building extension\n- [x] styles.css file exists at src/tasks/providers/styles.css\n- [x] Current implementation fails in packaged extension due to file path issues\n- [x] TaskHTMLGenerator.getInlineCSS() has fallback CSS that lacks proper styling\n\n## Implementation Specification\n### Exact Webpack Configuration\n```javascript\n// webpack.config.js - Add to module.rules array\n{\n  test: /\\.css$/,\n  use: 'raw-loader'\n}\n```\n\n### Updated TaskHTMLGenerator Method\n```typescript\n// Import bundled CSS at top of file\nimport cssContent from './styles.css';\n\nexport class TaskHTMLGenerator {\n  // Remove static cssCache and file reading logic\n  \n  private getInlineCSS(): string {\n    // CSS is now bundled at build time\n    return cssContent;\n  }\n  \n  // Remove getFallbackCSS() method and file reading try/catch\n}\n```\n\n### Install Raw Loader Dependency\n```bash\nnpm install --save-dev raw-loader\n```\n\n### Single Test Case\n```typescript\nit('should return bundled CSS without file system access', () => {\n  const fsSpy = jest.spyOn(require('fs'), 'readFileSync');\n  \n  const html = generator.generateFullHTML([]);\n  \n  // No file system reads should occur\n  expect(fsSpy).not.toHaveBeenCalled();\n  // CSS should be present and contain task-expand-icon styles\n  expect(html).toContain('.task-expand-icon');\n  expect(html).toContain('width: 12px');\n  \n  fsSpy.mockRestore();\n});\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] Webpack bundles CSS content at build time\n- [x] No runtime file system access for CSS\n- [x] Generated HTML contains full styling (not fallback CSS)\n- [x] Extension works correctly when packaged\n- [x] Task expand icons are properly sized (12px)\n\n## File Changes (Maximum 3 Files)\n### Primary File: webpack.config.js\n- Add: raw-loader rule for CSS files\n- Purpose: Bundle CSS at build time\n\n### Secondary File: src/tasks/providers/TaskHTMLGenerator.ts\n- Remove: File reading logic and caching\n- Add: CSS import statement\n- Modify: getInlineCSS() to return imported content\n- Purpose: Use build-time bundled CSS\n\n### Package File: package.json (if raw-loader not installed)\n- Add: raw-loader as devDependency\n- Purpose: Enable CSS bundling in webpack\n\n## Validation Commands\n```bash\nnpm install  # Install raw-loader if needed\nnpm run compile  # Test webpack bundling\nnpm test -- --testPathPattern=\"TaskHTMLGenerator\"\n# Manual test: Check webview styling works\n```\n\n## Rollback Strategy\n```bash\ngit checkout HEAD -- webpack.config.js src/tasks/providers/TaskHTMLGenerator.ts\n# Remove raw-loader if installed: npm uninstall raw-loader\n```",
    "contextFiles": ["webpack.config.js", "src/tasks/providers/TaskHTMLGenerator.ts"],
    "tddPhase": "Green", 
    "validationSteps": [
      "Add raw-loader rule to webpack.config.js for CSS files",
      "Update TaskHTMLGenerator to import CSS instead of reading file",
      "Verify webpack bundles CSS content at build time",
      "Test that generated HTML contains full styling not fallback CSS"
    ],
    "rollbackCommand": "git checkout HEAD -- webpack.config.js src/tasks/providers/TaskHTMLGenerator.ts",
    "successSignals": [
      "CSS bundled at build time with webpack",
      "No runtime file system access for CSS",
      "Task expand icons properly sized (fixes huge arrow issue)"
    ]
  },
  "PERF-003": {
    "taskId": "PERF-003",
    "title": "Bundle JavaScript content with webpack raw-loader",
    "promptContent": "# Atomic Task Implementation: PERF-003 - Bundle JavaScript content with webpack raw-loader\n\n## Single-Concern Focus\nConfigure webpack to bundle webview.js content at build time, following the same pattern as CSS bundling from PERF-002.\n\n## Sprint Context\n- **Sprint Day**: 3-4 of 2-week sprint\n- **Priority**: P2-Nice to Have (consistency with CSS bundling)\n- **Dependencies**: PERF-002 (webpack raw-loader configuration established)\n- **Fallback Plan**: Keep existing inline JavaScript if bundling complex\n\n## Context Files (Maximum 2)\n- Target file: src/tasks/providers/TaskHTMLGenerator.ts (getInlineJavaScript method)\n- Reference: src/tasks/providers/webview.js (149 lines to be bundled)\n\n## Task Scope\n- ID: PERF-003\n- Single Responsibility: Bundle JavaScript at build time via webpack\n- Input: External webview.js file (149 lines)\n- Output: JavaScript bundled as string in JavaScript bundle\n- Duration: 15 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Green\n- Implementing build-time bundling following CSS pattern\n\n## Prerequisites Verified\n- [x] PERF-002 webpack CSS bundling working correctly\n- [x] raw-loader already configured in webpack.config.js\n- [x] webview.js file exists at src/tasks/providers/webview.js\n- [x] getInlineJavaScript() method currently reads file at runtime\n\n## Implementation Specification\n### Webpack Configuration (Already Done)\n```javascript\n// webpack.config.js - raw-loader should already handle .js files\n// If not, add rule:\n{\n  test: /\\.js$/,\n  include: path.resolve(__dirname, 'src/tasks/providers'),\n  use: 'raw-loader'\n}\n```\n\n### Updated TaskHTMLGenerator Method\n```typescript\n// Import bundled JavaScript at top of file\nimport jsContent from './webview.js';\n\nexport class TaskHTMLGenerator {\n  // Remove static jsCache and file reading logic\n  \n  private getInlineJavaScript(): string {\n    // JavaScript is now bundled at build time\n    return jsContent;\n  }\n  \n  // Remove file reading try/catch and fallback logic\n}\n```\n\n### Single Test Case\n```typescript\nit('should return bundled JavaScript without file system access', () => {\n  const fsSpy = jest.spyOn(require('fs'), 'readFileSync');\n  \n  const html = generator.generateFullHTML([]);\n  \n  // No file system reads should occur\n  expect(fsSpy).not.toHaveBeenCalled();\n  // JavaScript should be present and contain expected functions\n  expect(html).toContain('function toggleTask');\n  expect(html).toContain('expandedTaskId');\n  \n  fsSpy.mockRestore();\n});\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] Webpack bundles JavaScript content at build time\n- [x] No runtime file system access for JavaScript\n- [x] All interactive webview features work (accordion, filters)\n- [x] Generated HTML contains expected JavaScript functions\n- [x] Extension works correctly when packaged\n\n## File Changes (Maximum 3 Files)\n### Primary File: src/tasks/providers/TaskHTMLGenerator.ts\n- Remove: File reading logic for JavaScript\n- Add: JavaScript import statement\n- Modify: getInlineJavaScript() to return imported content\n- Purpose: Use build-time bundled JavaScript\n\n### Secondary File: webpack.config.js (if needed)\n- Add: specific rule for .js files in tasks/providers directory\n- Purpose: Ensure JavaScript files are handled by raw-loader\n\n## Validation Commands\n```bash\nnpm run compile  # Test webpack bundling\nnpm test -- --testPathPattern=\"TaskHTMLGenerator\"\n# Manual test: Verify webview accordion and filters work\n```\n\n## Rollback Strategy\n```bash\ngit checkout HEAD -- webpack.config.js src/tasks/providers/TaskHTMLGenerator.ts\n```",
    "contextFiles": ["src/tasks/providers/TaskHTMLGenerator.ts", "src/tasks/providers/webview.js"],
    "tddPhase": "Green",
    "validationSteps": [
      "Update TaskHTMLGenerator to import JavaScript instead of reading file",
      "Verify webpack bundles JavaScript content at build time", 
      "Test that all webview interactive features still work",
      "Confirm no runtime file system access for JavaScript"
    ],
    "rollbackCommand": "git checkout HEAD -- webpack.config.js src/tasks/providers/TaskHTMLGenerator.ts",
    "successSignals": [
      "JavaScript bundled at build time with webpack",
      "No runtime file system access for JavaScript",
      "All interactive webview features working correctly"
    ]
  },
  "PERF-004": {
    "taskId": "PERF-004",
    "title": "Create performance benchmark test suite",
    "promptContent": "# Atomic Task Implementation: PERF-004 - Create performance benchmark test suite\n\n## Single-Concern Focus\nCreate automated performance tests to measure and validate webview rendering performance improvements.\n\n## Sprint Context\n- **Sprint Day**: 4-5 of 2-week sprint\n- **Priority**: P1-High Impact (validation of optimizations)\n- **Dependencies**: PERF-001, PERF-002 (core optimizations to measure)\n- **Fallback Plan**: Manual performance testing if automated tests complex\n\n## Context Files (Maximum 2)\n- Target: New file src/__tests__/performance/WebviewPerformance.test.ts\n- Reference: src/tasks/providers/TaskHTMLGenerator.ts (performance target)\n\n## Task Scope\n- ID: PERF-004\n- Single Responsibility: Automated performance measurement\n- Input: Task data and HTML generation methods\n- Output: Performance benchmarks with pass/fail criteria\n- Duration: 20 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Red\n- Creating tests to validate performance requirements\n\n## Prerequisites Verified\n- [x] PERF-001 and PERF-002 optimizations implemented\n- [x] TaskHTMLGenerator available for testing\n- [x] Jest testing framework configured\n\n## Implementation Specification\n### Exact Test File\n```typescript\n// src/__tests__/performance/WebviewPerformance.test.ts\nimport { TaskHTMLGenerator } from '../../tasks/providers/TaskHTMLGenerator';\nimport { Task, TaskStatus } from '../../types/tasks';\nimport * as vscode from 'vscode';\n\ndescribe('Webview Performance Benchmarks', () => {\n  let generator: TaskHTMLGenerator;\n  let mockTasks: Task[];\n  \n  beforeEach(() => {\n    generator = new TaskHTMLGenerator(vscode.Uri.file('/mock'));\n    mockTasks = createMockTasks(10); // Helper function\n  });\n  \n  it('should generate HTML in under 100ms', async () => {\n    const start = performance.now();\n    \n    const html = generator.generateFullHTML(mockTasks);\n    \n    const end = performance.now();\n    const duration = end - start;\n    \n    expect(duration).toBeLessThan(100);\n    expect(html).toContain('task-item');\n  });\n  \n  it('should use bundled CSS and avoid file system access', () => {\n    const fsSpy = jest.spyOn(require('fs'), 'readFileSync');\n    \n    // Multiple generations should not read files at all\n    const html1 = generator.generateFullHTML(mockTasks);\n    const html2 = generator.generateFullHTML(mockTasks);\n    const html3 = generator.generateFullHTML(mockTasks);\n    \n    // No file system reads should occur with bundled CSS\n    expect(fsSpy).not.toHaveBeenCalled();\n    \n    // All HTML should contain proper styling\n    [html1, html2, html3].forEach(html => {\n      expect(html).toContain('.task-expand-icon');\n      expect(html).toContain('width: 12px');\n    });\n    fsSpy.mockRestore();\n  });\n});\n\nfunction createMockTasks(count: number): Task[] {\n  return Array(count).fill(null).map((_, i) => ({\n    id: `TASK-${i.toString().padStart(3, '0')}`,\n    title: `Sample Task ${i}`,\n    description: 'Sample task description',\n    status: TaskStatus.NOT_STARTED,\n    // ... other required fields\n  }));\n}\n```\n\n### Directory Creation\n```bash\nmkdir -p src/__tests__/performance\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] Performance test file created and runs successfully\n- [x] HTML generation benchmark passes (<100ms target)\n- [x] Build-time CSS bundling validation test passes\n- [x] Tests provide clear performance metrics\n\n## File Changes (Maximum 3 Files)\n### Primary File: src/__tests__/performance/WebviewPerformance.test.ts\n- Create: New performance test suite\n- Test: HTML generation speed and caching effectiveness\n- Purpose: Automated validation of performance improvements\n\n## Validation Commands\n```bash\nnpm test -- --testPathPattern=\"WebviewPerformance\"\nnpm test -- --testPathPattern=\"performance\" --verbose\n```\n\n## Rollback Strategy\n```bash\nrm -f src/__tests__/performance/WebviewPerformance.test.ts\nrmdir src/__tests__/performance\n```",
    "contextFiles": ["src/tasks/providers/TaskHTMLGenerator.ts"],
    "tddPhase": "Red",
    "validationSteps": [
      "Create performance test directory structure",
      "Write HTML generation speed benchmark test",
      "Add build-time CSS bundling validation test", 
      "Verify tests run and pass with current optimizations"
    ],
    "rollbackCommand": "rm -rf src/__tests__/performance/",
    "successSignals": [
      "Performance tests execute successfully",
      "HTML generation under 100ms benchmark passes",
      "Build-time CSS bundling behavior validated"
    ]
  },
  "PERF-005": {
    "taskId": "PERF-005",
    "title": "Validate overall performance improvement",
    "promptContent": "# Atomic Task Implementation: PERF-005 - Validate overall performance improvement\n\n## Single-Concern Focus\nMeasure and validate the combined effect of all Phase 1 optimizations achieves 70-80% performance improvement.\n\n## Sprint Context\n- **Sprint Day**: 5-6 of 2-week sprint\n- **Priority**: P0-Critical Path (validates optimization success)\n- **Dependencies**: PERF-001, PERF-002, PERF-003, PERF-004 (all optimizations)\n- **Fallback Plan**: Identify which optimization provides most benefit\n\n## Context Files (Maximum 2)\n- Target: src/__tests__/integration/TasksDataService.integration.test.ts\n- Reference: All optimized components for end-to-end measurement\n\n## Task Scope\n- ID: PERF-005\n- Single Responsibility: Comprehensive performance validation\n- Input: Complete task loading workflow\n- Output: Performance metrics showing 70-80% improvement\n- Duration: 15 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Green\n- Validating that all optimizations work together effectively\n\n## Prerequisites Verified\n- [x] All PERF-001 through PERF-004 tasks completed\n- [x] Individual optimizations working correctly\n- [x] Performance test framework available\n\n## Implementation Specification\n### Exact Test Addition\n```typescript\n// Add to existing TasksDataService.integration.test.ts\ndescribe('Performance Integration Tests', () => {\n  it('should load tasks with optimized performance', async () => {\n    const start = performance.now();\n    \n    // Complete task loading workflow\n    const tasks = await tasksDataService.getTasks();\n    const htmlGenerator = new TaskHTMLGenerator(extensionUri);\n    const html = htmlGenerator.generateFullHTML(tasks);\n    \n    const end = performance.now();\n    const totalTime = end - start;\n    \n    // Target: Under 1000ms total (was 2000ms+ before)\n    expect(totalTime).toBeLessThan(1000);\n    expect(tasks.length).toBeGreaterThan(0);\n    expect(html).toContain('task-item');\n    \n    console.log(`Task loading performance: ${totalTime.toFixed(2)}ms`);\n  });\n  \n  it('should demonstrate performance improvement over baseline', async () => {\n    // Measure optimized path\n    const optimizedTime = await measureTaskLoadingTime();\n    \n    // Expected improvement: 70-80% faster than original 2000ms\n    const maxAcceptableTime = 600; // 70% improvement from 2000ms\n    \n    expect(optimizedTime).toBeLessThan(maxAcceptableTime);\n  });\n});\n\nasync function measureTaskLoadingTime(): Promise<number> {\n  const start = performance.now();\n  \n  const tasks = await tasksDataService.getTasks();\n  const generator = new TaskHTMLGenerator(extensionUri);\n  generator.generateFullHTML(tasks);\n  \n  return performance.now() - start;\n}\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] End-to-end task loading under 1000ms (was 2000ms+)\n- [x] Performance improvement of 70-80% demonstrated\n- [x] All functionality preserved (no regressions)\n- [x] Performance metrics logged for validation\n\n## File Changes (Maximum 3 Files)\n### Primary File: src/__tests__/integration/TasksDataService.integration.test.ts\n- Add: Performance integration test suite\n- Measure: Complete task loading workflow\n- Validate: 70-80% improvement from baseline\n- Purpose: Prove optimization success\n\n## Validation Commands\n```bash\nnpm test -- --testPathPattern=\"TasksDataService.integration\"\nnpm test -- --testPathPattern=\"integration\" --verbose\n# Manual verification in VSCode extension\n```\n\n## Rollback Strategy\n```bash\ngit revert [commits from PERF-001 through PERF-003]\n# Individual task rollbacks if needed\n```",
    "contextFiles": ["src/__tests__/integration/TasksDataService.integration.test.ts"],
    "tddPhase": "Green",
    "validationSteps": [
      "Add end-to-end performance measurement test",
      "Measure complete task loading workflow time",
      "Validate 70-80% improvement from 2000ms baseline",
      "Verify no functional regressions introduced"
    ],
    "rollbackCommand": "git revert $(git log --oneline | grep PERF-00[1-4] | cut -d' ' -f1)",
    "successSignals": [
      "Task loading under 1000ms consistently",
      "70-80% performance improvement validated",
      "All features working correctly"
    ]
  },
  "PERF-006": {
    "taskId": "PERF-006", 
    "title": "Extract HTML templates to external files",
    "promptContent": "# Atomic Task Implementation: PERF-006 - Extract HTML templates to external files\n\n## Single-Concern Focus\nMove large HTML template strings from TaskHTMLGenerator to external .html files for improved maintainability.\n\n## Sprint Context\n- **Sprint Day**: 7-8 of 2-week sprint\n- **Priority**: P2-Nice to Have (maintainability improvement)\n- **Dependencies**: PERF-005 (performance baseline established)\n- **Fallback Plan**: Keep current inline templates if complexity too high\n\n## Context Files (Maximum 2)\n- Target: src/tasks/providers/TaskHTMLGenerator.ts (large template strings)\n- New: src/tasks/templates/ directory for external files\n\n## Task Scope\n- ID: PERF-006\n- Single Responsibility: Externalize HTML templates\n- Input: Inline template strings in generateTaskItem()\n- Output: External .html files with template placeholders\n- Duration: 20 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Refactor\n- Improving maintainability while preserving functionality\n\n## Prerequisites Verified\n- [x] Performance optimizations from Phase 1 complete\n- [x] Large template strings identified in TaskHTMLGenerator\n- [x] Template extraction won't impact performance gains\n\n## Implementation Specification\n### Template Files to Create\n```html\n<!-- src/tasks/templates/task-item.html -->\n<div class=\"task-item\" data-task-id=\"{{id}}\" data-assignee=\"{{assignee}}\">\n  {{header}}\n  {{details}}\n  {{subtasks}}\n</div>\n\n<!-- src/tasks/templates/task-header.html -->\n<div class=\"task-header{{executableClass}}\">\n  <svg class=\"task-expand-icon\" viewBox=\"0 0 16 16\" fill=\"currentColor\" onclick=\"toggleTask(this.closest('.task-item'))\">\n    <path d=\"m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z\"/>\n  </svg>\n  <span class=\"task-id\">{{id}}</span>\n  <span class=\"task-title\" data-task-field=\"title\"></span>\n  <span class=\"task-status {{statusClass}}\">{{statusDisplay}}</span>\n  {{executableIcon}}\n</div>\n```\n\n### Updated TaskHTMLGenerator Method\n```typescript\nprivate static templateCache = new Map<string, string>();\n\nprivate loadTemplate(templateName: string): string {\n  if (!TaskHTMLGenerator.templateCache.has(templateName)) {\n    const templatePath = path.join(__dirname, '..', 'templates', `${templateName}.html`);\n    const template = fs.readFileSync(templatePath, 'utf8');\n    TaskHTMLGenerator.templateCache.set(templateName, template);\n  }\n  return TaskHTMLGenerator.templateCache.get(templateName)!;\n}\n\nprivate generateTaskItem(task: Task): string {\n  const template = this.loadTemplate('task-item');\n  return template\n    .replace('{{id}}', task.id)\n    .replace('{{assignee}}', task.assignee || 'dev-team')\n    .replace('{{header}}', this.generateTaskHeader(task))\n    .replace('{{details}}', this.generateTaskDetails(task))\n    .replace('{{subtasks}}', this.generateSubtasksSection(task));\n}\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] HTML templates extracted to external files\n- [x] Template caching implemented for performance\n- [x] Generated HTML identical to previous version\n- [x] Syntax highlighting available in template files\n\n## File Changes (Maximum 3 Files)\n### Primary File: src/tasks/providers/TaskHTMLGenerator.ts\n- Add: Template loading and caching methods\n- Modify: generateTaskItem() to use external templates\n- Purpose: Improved maintainability\n\n### Template Files: src/tasks/templates/\n- Create: task-item.html, task-header.html\n- Purpose: External template storage\n\n## Validation Commands\n```bash\nmkdir -p src/tasks/templates\nnpm test -- --testPathPattern=\"TaskHTMLGenerator\"\n# Verify HTML output unchanged\n```\n\n## Rollback Strategy\n```bash\ngit checkout HEAD -- src/tasks/providers/TaskHTMLGenerator.ts\nrm -rf src/tasks/templates/\n```",
    "contextFiles": ["src/tasks/providers/TaskHTMLGenerator.ts"],
    "tddPhase": "Refactor",
    "validationSteps": [
      "Create templates directory and HTML files",
      "Add template loading with caching to TaskHTMLGenerator",
      "Verify generated HTML matches previous output exactly",
      "Test template syntax highlighting in editor"
    ],
    "rollbackCommand": "git checkout HEAD -- src/tasks/providers/TaskHTMLGenerator.ts && rm -rf src/tasks/templates/",
    "successSignals": [
      "External template files created with syntax highlighting",
      "Template caching working correctly",
      "HTML output functionally identical"
    ]
  },
  "PERF-007": {
    "taskId": "PERF-007",
    "title": "Implement template file caching system",
    "promptContent": "# Atomic Task Implementation: PERF-007 - Implement template file caching system\n\n## Single-Concern Focus\nCreate proper caching mechanism for external HTML template files using VSCode filesystem API and webview URIs.\n\n## Sprint Context\n- **Sprint Day**: 8-9 of 2-week sprint\n- **Priority**: P2-Nice to Have (infrastructure for future)\n- **Dependencies**: PERF-006 (external templates exist)\n- **Fallback Plan**: Use simple fs.readFileSync with caching\n\n## Context Files (Maximum 2)\n- Target: src/tasks/providers/TaskHTMLGenerator.ts (template loading)\n- Reference: VSCode webview asWebviewUri best practices\n\n## Task Scope\n- ID: PERF-007\n- Single Responsibility: VSCode-compliant template caching\n- Input: External template files\n- Output: Cached templates with proper webview URIs\n- Duration: 20 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Green\n- Implementing proper VSCode filesystem integration\n\n## Prerequisites Verified\n- [x] PERF-006 external templates created and working\n- [x] VSCode filesystem API available\n- [x] Template caching pattern established\n\n## Implementation Specification\n### Enhanced Template Loading\n```typescript\nexport class TaskHTMLGenerator {\n  private static templateCache = new Map<string, string>();\n  private webview?: vscode.Webview;\n  \n  setWebview(webview: vscode.Webview): void {\n    this.webview = webview;\n  }\n  \n  private async loadTemplate(templateName: string): Promise<string> {\n    if (!TaskHTMLGenerator.templateCache.has(templateName)) {\n      const templateUri = vscode.Uri.joinPath(\n        this.extensionUri, \n        'src', 'tasks', 'templates', \n        `${templateName}.html`\n      );\n      \n      try {\n        const templateBytes = await vscode.workspace.fs.readFile(templateUri);\n        const template = Buffer.from(templateBytes).toString('utf8');\n        TaskHTMLGenerator.templateCache.set(templateName, template);\n      } catch (error) {\n        console.warn(`Failed to load template ${templateName}:`, error);\n        // Fallback to inline template\n        TaskHTMLGenerator.templateCache.set(templateName, this.getFallbackTemplate(templateName));\n      }\n    }\n    return TaskHTMLGenerator.templateCache.get(templateName)!;\n  }\n  \n  private getFallbackTemplate(templateName: string): string {\n    // Provide inline fallbacks for critical templates\n    switch (templateName) {\n      case 'task-item':\n        return '<div class=\"task-item\" data-task-id=\"{{id}}\">{{content}}</div>';\n      default:\n        return '<div>{{content}}</div>';\n    }\n  }\n}\n```\n\n### CSP Compliance Test\n```typescript\nit('should load templates with proper CSP compliance', async () => {\n  const generator = new TaskHTMLGenerator(extensionUri);\n  const mockWebview = {\n    asWebviewUri: jest.fn((uri) => uri),\n    options: { localResourceRoots: [extensionUri] }\n  };\n  \n  generator.setWebview(mockWebview as any);\n  const html = await generator.generateFullHTML(mockTasks);\n  \n  expect(html).not.toContain('file://');\n  expect(html).toContain('task-item');\n});\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] Templates loaded via VSCode filesystem API\n- [x] Template caching works with async loading\n- [x] CSP compliance maintained\n- [x] Fallback templates for error cases\n\n## File Changes (Maximum 3 Files)\n### Primary File: src/tasks/providers/TaskHTMLGenerator.ts\n- Modify: Template loading to use VSCode APIs\n- Add: Async template loading with caching\n- Add: CSP-compliant resource handling\n- Purpose: Proper VSCode integration\n\n## Validation Commands\n```bash\nnpm test -- --testPathPattern=\"TaskHTMLGenerator\"\n# Test CSP compliance in actual webview\nnpm run compile\n```\n\n## Rollback Strategy\n```bash\ngit checkout HEAD -- src/tasks/providers/TaskHTMLGenerator.ts\n```",
    "contextFiles": ["src/tasks/providers/TaskHTMLGenerator.ts"],
    "tddPhase": "Green",
    "validationSteps": [
      "Update template loading to use VSCode filesystem API",
      "Implement async template caching system",
      "Add fallback templates for error handling",
      "Verify CSP compliance with webview resources"
    ],
    "rollbackCommand": "git checkout HEAD -- src/tasks/providers/TaskHTMLGenerator.ts",
    "successSignals": [
      "Templates loaded via VSCode APIs",
      "Async caching working correctly", 
      "CSP compliance maintained",
      "Error fallbacks functional"
    ]
  },
  "PERF-008": {
    "taskId": "PERF-008",
    "title": "Add template compilation build step",
    "promptContent": "# Atomic Task Implementation: PERF-008 - Add template compilation build step\n\n## Single-Concern Focus\nCreate optional build script to pre-compile HTML templates into optimized TypeScript functions for maximum performance.\n\n## Sprint Context\n- **Sprint Day**: 10-11 of 2-week sprint\n- **Priority**: P3-Future Enhancement (advanced optimization)\n- **Dependencies**: PERF-007 (template system established)\n- **Fallback Plan**: Skip template compilation, use runtime templates\n\n## Context Files (Maximum 2)\n- New: scripts/compile-templates.js (build script)\n- Update: package.json (build commands)\n\n## Task Scope\n- ID: PERF-008\n- Single Responsibility: Template pre-compilation system\n- Input: HTML template files\n- Output: Generated TypeScript template functions\n- Duration: 20 minutes maximum\n\n## TDD Cycle Position\nCurrent Cycle: Green\n- Adding advanced optimization feature\n\n## Prerequisites Verified\n- [x] External template system working (PERF-007)\n- [x] Template caching established\n- [x] Build system available for extension\n\n## Implementation Specification\n### Build Script\n```javascript\n// scripts/compile-templates.js\nconst fs = require('fs');\nconst path = require('path');\n\nfunction compileTemplates() {\n  const templatesDir = path.join(__dirname, '..', 'src', 'tasks', 'templates');\n  const outputFile = path.join(__dirname, '..', 'src', 'tasks', 'providers', 'CompiledTemplates.ts');\n  \n  const templateFiles = fs.readdirSync(templatesDir)\n    .filter(file => file.endsWith('.html'));\n  \n  let output = `// Auto-generated template functions\\n// Generated from: ${templateFiles.join(', ')}\\n\\n`;\n  \n  templateFiles.forEach(file => {\n    const templateName = path.basename(file, '.html');\n    const templateContent = fs.readFileSync(path.join(templatesDir, file), 'utf8');\n    \n    // Convert to TypeScript template function\n    const functionName = templateName.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n    \n    output += `export function ${functionName}Template(data: any): string {\\n`;\n    output += `  return \\`${templateContent.replace(/\\{\\{(.*?)\\}\\}/g, '${data.$1}').replace(/`/g, '\\\\`')}\\`;\\n`;\n    output += `}\\n\\n`;\n  });\n  \n  fs.writeFileSync(outputFile, output);\n  console.log(`Compiled ${templateFiles.length} templates to ${outputFile}`);\n}\n\nif (require.main === module) {\n  compileTemplates();\n}\n\nmodule.exports = { compileTemplates };\n```\n\n### Package.json Addition\n```json\n{\n  \"scripts\": {\n    \"compile-templates\": \"node scripts/compile-templates.js\",\n    \"prebuild\": \"npm run compile-templates\"\n  }\n}\n```\n\n### Optional Usage in TaskHTMLGenerator\n```typescript\n// Optional: Use compiled templates for maximum performance\ntry {\n  const { taskItemTemplate } = require('./CompiledTemplates');\n  return taskItemTemplate(task);\n} catch {\n  // Fallback to runtime template loading\n  return this.loadTemplate('task-item');\n}\n```\n\n## Success Criteria (Binary Pass/Fail)\n- [x] Build script runs successfully\n- [x] Compiled TypeScript templates generated\n- [x] Templates functional and performant\n- [x] Optional usage doesn't break existing system\n\n## File Changes (Maximum 3 Files)\n### Primary File: scripts/compile-templates.js\n- Create: Template compilation build script\n- Purpose: Pre-compile HTML to TypeScript\n\n### Secondary File: package.json\n- Add: Template compilation npm script\n- Purpose: Integrate with build process\n\n## Validation Commands\n```bash\nnpm run compile-templates\nnpm run compile\n# Verify generated CompiledTemplates.ts works\n```\n\n## Rollback Strategy\n```bash\nrm -f scripts/compile-templates.js\ngit checkout HEAD -- package.json\nrm -f src/tasks/providers/CompiledTemplates.ts\n```",
    "contextFiles": ["package.json"],
    "tddPhase": "Green",
    "validationSteps": [
      "Create template compilation build script",
      "Add npm script for template compilation",
      "Test compilation generates valid TypeScript",
      "Verify optional integration with existing system"
    ],
    "rollbackCommand": "rm -f scripts/compile-templates.js && git checkout HEAD -- package.json && rm -f src/tasks/providers/CompiledTemplates.ts",
    "successSignals": [
      "Template compilation script runs successfully",
      "Generated TypeScript templates functional",
      "Build integration working correctly"
    ]
  }
}